import { prebuild } from '@mintlify/prebuild';
import fse from 'fs-extra';
import isOnline from 'is-online';
import { mockProcessExit } from 'vitest-mock-process';
import { dev } from '../index.js';
import { downloadTargetMint, getTargetMintVersion } from '../local-preview/client.js';
import { run } from '../local-preview/run.js';
import * as logs from '../logging-state.js';
const originalChdir = process.chdir;
vi.mock('fs-extra', () => {
    const mocks = {
        ensureDir: vi.fn().mockResolvedValue(undefined),
        pathExists: vi.fn().mockResolvedValue(true),
        readFileSync: vi.fn().mockReturnValue('1.0.0'),
        emptyDirSync: vi.fn().mockResolvedValue(undefined),
    };
    return {
        ...mocks,
        default: mocks,
    };
});
vi.mock('../local-preview/client.js', () => ({
    getTargetMintVersion: vi.fn().mockResolvedValue('1.0.0'),
    downloadTargetMint: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('is-online', () => ({
    default: vi.fn().mockResolvedValue(true),
}));
vi.mock('@mintlify/prebuild', () => ({
    prebuild: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('../local-preview/run.js', () => ({
    run: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('../util.js', () => {
    return {
        maybeFixMissingWindowsEnvVar: vi.fn(),
    };
});
const prebuildMock = vi.mocked(prebuild);
const runMock = vi.mocked(run);
const downloadTargetMintMock = vi.mocked(downloadTargetMint);
const defaultYargs = {
    _: [],
    $0: '',
    packageName: 'mintlify',
};
const addLogSpy = vi.spyOn(logs, 'addLog');
const processExitMock = mockProcessExit();
describe('dev', () => {
    beforeEach(() => {
        process.chdir = vi.fn();
        vi.clearAllMocks();
    });
    afterEach(() => {
        process.chdir = originalChdir;
    });
    it('happy path', async () => {
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: 'preparing local preview...' } }));
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
    it('prebuild fails', async () => {
        const errorText = 'Some OpenAPI or docs.json schema error';
        prebuildMock.mockRejectedValueOnce(new Error(errorText));
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: 'preparing local preview...' } }));
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: errorText } }));
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
    it('fails if no existing client version and no internet', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev(defaultYargs).catch(() => { });
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({
            props: { message: 'running mintlify dev after updating requires an internet connection.' },
        }));
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
    it('fails if no existing client version and no internet - mint command', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev({ ...defaultYargs, packageName: 'mint' }).catch(() => { });
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({
            props: { message: 'running mint dev after updating requires an internet connection.' },
        }));
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
    it('has existing version but fails to get targetMintVersion', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(getTargetMintVersion).mockResolvedValueOnce(undefined);
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({
            props: {
                message: 'failed to retrieve latest version. Your current version is: 1.0.0, which may not be the latest version.',
            },
        }));
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
    it('downloads client with --client-version arg', async () => {
        await dev({ ...defaultYargs, 'client-version': '1.0.3' });
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: 'preparing local preview...' } }));
        expect(downloadTargetMintMock).toHaveBeenCalled();
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
    it('downloads client if no existing version', async () => {
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { message: 'preparing local preview...' } }));
        expect(downloadTargetMintMock).toHaveBeenCalled();
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
    it('warns about update if target version is different from existing version', async () => {
        vi.mocked(getTargetMintVersion).mockResolvedValueOnce('1.0.1');
        await dev(defaultYargs);
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { updateCommand: 'mintlify update' } }));
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
    it('warns about update if target version is different from existing version - mint command', async () => {
        vi.mocked(getTargetMintVersion).mockResolvedValueOnce('1.0.1');
        await dev({ ...defaultYargs, packageName: 'mint' });
        expect(addLogSpy).toHaveBeenCalledWith(expect.objectContaining({ props: { updateCommand: 'mint update' } }));
        expect(prebuildMock).toHaveBeenCalled();
        expect(runMock).toHaveBeenCalled();
    });
});
